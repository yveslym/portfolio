from flask import Flask, request, make_response
from flask_restful import Resource, Api
from pymongo import MongoClient
from bson.objectid import ObjectId
#from utils.mongo_json_encoder import JSONEncoder

# Basic Setup
# 1
app = Flask(__name__)
# 2
mongo = MongoClient('localhost', 27017)
# 3
app.db = mongo.BlogDB
# 4
api = Api(app)

#Implement REST Resource

class MyObject(Resource):
    # posting data in database from the cloud(on json format, which is    dict
    def post(self):
        #1We access the JSON that the client provided through the request.json variable. The request
        #variable is implicitly available through the request context.
        new_myobject = request.json
            
            #2 We access the collection in which we will store the new object. Typically we create
            #one collection per entitiy type (e.g. User, Post, etc.).
        myobject_collection = app.db.myobjects
               
       #3 We insert the JSON document into the collection. MongoDB is schema free, this means we can
       #store JSON of any arbitrary structure in this collection. In a more complex application you
       #would might want to validate the JSON structure to a certain degree. For this application we
       #will trust the client to provide the correctly structured information.
        result = myobject_collection.insert_one(new_myobject)
            
        #4After inserting the document we retrieve the result. Then we use this result to
        #fetch the inserted document from the collection using the find_one method. The
        #find_one method takes a dictionary that describes the filter criteria for our
        #documents (in this case documents with a specific id). The _id field is
        #automatically maintained by MongoDB and stores the unique identifier for each
        #document that is stored. Note that we need to wrap the
        #result.inserted_id into an ObjectId type. The ObjectId type is not a string! If you try to
        #compare it to a string you won't get any results.
        myobject = myobject_collection.find_one({"_id": ObjectId(result.inserted_id)})
                
        #5We return the selected document to the client. Now the client will be able to retrieve the
        #_id generated by MongoDB and will know which id is associated with the new document on the server.
        return myobject

def get(self, myobject_id):
    #getting data from the database to send to the cloud
    
    #6 We reference the myobjects collection from which we'll select the document that the client is trying to access.
    myobject_collection = app.db.myobjects
        
        #7 We build a query based on the myobject_id that we have received as part of the client's request. Later you'll see how this argument is handed to the get method.
    myobject = myobject_collection.find_one({"_id": ObjectId(myobject_id)})
        
        #8 If we can't find a document with the provided id we return a 404 status code. If we found a document we return it to the client.
    if myobject is None:
        response = jsonify(data=[])
        response.status_code = 404
        return response
    else:
        return myobject
    # provide a custom JSON serializer for flask_restful
@api.representation('application/json')
def output_json(data, code, headers=None):
    resp = make_response(JSONEncoder().encode(data), code)
    resp.headers.extend(headers or {})
    return resp
def setUp(self):
    self.app = server.app.test_client()
    # Run app in testing mode to retrieve exceptions and stack traces
    server.app.config['TESTING'] = True
        
        # Inject test database into application
    mongo = MongoClient('localhost', 27017)
    db = mongo.test_database
    server.app.db = db
                
    # Drop collection (significantly faster than dropping entire db)
    db.drop_collection('myobjects')


if __name__ == '__main__':
    # Turn this on in debug mode to get detailled information about request related exceptions: http://flask.pocoo.org/docs/0.10/config/
    app.config['TRAP_BAD_REQUEST_ERRORS'] = True
    app.run(debug=True)
















